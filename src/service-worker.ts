/// <reference lib="webworker" />

import { build, files, timestamp } from '$service-worker';

const worker = self as unknown as ServiceWorkerGlobalScope;
const FILES = `cache${timestamp}`;

// `build` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory
const to_cache = build.concat(files);
const staticAssets = new Set(to_cache);

worker.addEventListener('install', (event) => {
	event.waitUntil(
		caches
			.open(FILES)
			.then((cache) => cache.addAll(to_cache))
			.then(() => {
				worker.skipWaiting();
			})
	);
});

worker.addEventListener('activate', (event) => {
	event.waitUntil(
		caches.keys().then(async (keys) => {
			// delete old caches
			for (const key of keys) {
				if (key !== FILES) await caches.delete(key);
			}

			worker.clients.claim();
		})
	);
});

/**
 * Fetch the asset from the network and store it in the cache.
 * Fall back to the cache if the user is offline.
 */
async function fetchAndCache(request: Request) {
	const cache = await caches.open(`offline${timestamp}`);

	try {
		const response = await fetch(request);
		cache.put(request, response.clone());
		return response;
	} catch (err) {
		const response = await cache.match(request);
		if (response) return response;

		throw err;
	}
}

worker.addEventListener('fetch', (event) => {
	if (event.request.method !== 'GET' || event.request.headers.has('range')) return;

	const url = new URL(event.request.url);

	// don't try to handle e.g. data: URIs
	const isHttp = url.protocol.startsWith('http');
	const isDevServerRequest =
		url.hostname === self.location.hostname && url.port !== self.location.port;
	const isStaticAsset = url.host === self.location.host && staticAssets.has(url.pathname);
	const skipBecauseUncached = event.request.cache === 'only-if-cached' && !isStaticAsset;

	if (isHttp && !isDevServerRequest && !skipBecauseUncached) {
		event.respondWith(
			(async () => {
				// always serve static files and bundler-generated assets from cache.
				// if your application has other URLs with data that will never change,
				// set this variable to true for them and they will only be fetched once.
				const cachedAsset = isStaticAsset && (await caches.match(event.request));

				return cachedAsset || fetchAndCache(event.request);
			})()
		);
	}
});

// self.importScripts('./gun.js');
// self.importScripts('./sea.js');
// self.importScripts('./localforage.min.js');

// const urlToOpen = new URL('/', self.location.origin).href;
// var CACHE_NAME = 'flashear-cache-v1';

// async function getSavedKey() {
//   try {
//     self.flashear = await localforage.getItem('swflashear');
//   } catch (err) {
//     console.error('error loading iris key', err);
//   }
//   return self.flashear;
// }

// // stale-while-revalidate
// if (self.location.host.indexOf('localhost') !== 0) {
//   self.addEventListener('fetch', function(event) {
//     if (event.request && event.request.method !== 'GET') { return; }
//     event.respondWith(
//       caches.open(CACHE_NAME).then(function(cache) {
//         return cache.match(event.request).then(function(response) {
//           var fetchPromise = fetch(event.request).then(function(networkResponse) {
//             cache.put(event.request, networkResponse.clone());
//             return networkResponse;
//           })
//           return response || fetchPromise;
//         })
//       })
//     );
//   });
// }

// self.onmessage = function(msg) {
//   if (msg.data.hasOwnProperty('key')) {
//     self.flashear = msg.data.key;
//     localforage.setItem('swflashear', self.flashear);
//   }
// }

// function getOpenClient(event) {
//   return new Promise(resolve => {
//     event.waitUntil(
//       clients.matchAll({
//         type: "window",
//         includeUncontrolled: true
//       })
//       .then(function(clientList) {
//         for (var i = 0; i < clientList.length; i++) {
//           var client = clientList[i];
//           if (client.url === urlToOpen && 'focus' in client) return resolve(client);
//         }
//         resolve(null);
//       })
//     );
//   });
// }

// self.addEventListener('push', async ev => {
//   const client = await getOpenClient(ev);
//   if (client && client.visibilityState === 'visible') return;
//   if (!self.flashear) {
//     await getSavedKey();
//   }
//   const data = ev.data.json();
//   if (!data.title || !data.body) {
//     console.log('what?', data);
//   }
//   if (self.flashear && data.from && data.from.epub) {
//     const secret = await Gun.SEA.secret(data.from.epub, self.flashear);
//     data.title = await Gun.SEA.decrypt(data.title, secret);
//     data.body = await Gun.SEA.decrypt(data.body, secret);
//   }
//   if (data.title && data.title.indexOf('SEA{') === 0) {
//     data.title = '';
//     data.body = 'Encrypted message';
//   }
//   self.registration.showNotification(data.title || 'No title', {
//     body: data.body || 'No text',
//     icon: './img/icon128.png'
//   });
// });

// self.addEventListener('notificationclick', async function(event) {
//   // Android doesn't close the notification when you click on it
//   // See: http://crbug.com/463146
//   event.notification.close();

//   const client = await getOpenClient(event);
//   if (client) {
//     client.focus();
//   } else {
//     clients.openWindow && clients.openWindow(urlToOpen);
//   }
// });
